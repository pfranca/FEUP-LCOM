#include <minix/syslib.h>
#include <minix/drivers.h>
#include <minix/driver.h>
#include <minix/com.h>
#include <minix/sysutil.h>
#include "test4.h"
#include "keyboard.h"
#include "i8042.h"
#include "i8254.h"
#include "timer.h"
#include "mouse.h"

int mouse_test_packet(unsigned short cnt){



	int irq_set=mouse_subscribe_int();
	int ipc_status;
	message msg;
	int r;

	unsigned long byte;
	int packet_index = 0;
	int sync_flag = 0;
	unsigned short nrpackets = 0;
	unsigned long aux;

	if(irq_set>=0){
		irq_set=BIT(irq_set);
	} else {
		printf("Error in mouse_test_packet::mouse_subscribe_int()\n");
		return 1;
	}


	do{
		aux = mouse_set_stream_mode();
	}while(aux != ACK);


	do{
		aux = mouse_enable_data_report();
	}while(aux != ACK);

	while(nrpackets < cnt) {

			if ( (r = driver_receive(ANY, &msg, &ipc_status)) != 0 ) {
				printf("driver_receive failed with: %d", r);
				continue;
			}
			if (is_ipc_notify(ipc_status)) {
				switch (_ENDPOINT_P(msg.m_source)) {
				case HARDWARE:
					if (msg.NOTIFY_ARG & irq_set) {
						byte = kbc_read();

						packet[packet_index] = byte;

						if((packet[0] & BIT(3))==BIT(3)){
							sync_flag = 1;
						} else {
							sync_flag = 0;
							packet_index = 0;
						}

						if(sync_flag){
							packet_index++;
						 	if(packet_index>2){
								packet_index = 0;
								nrpackets++;
								mouse_display_packet(packet);
							}
						}

					}
					break;
				default:
					break;
				}
			} else {

			}


	}
	if(mouse_unsubscribe_int()){
		printf("Unsubscribe failed\n In mouse_test_packet::mouse_unsubscribe_int()\n");
		return 1;
	}

	kbc_read();
	return 0;
}

int mouse_test_async(unsigned short idle_time){
    return 1;
}	

int mouse_test_remote(unsigned long period, unsigned short cnt){
    return 1;
}	

int mouse_test_gesture(short length){
    return 1;
}
