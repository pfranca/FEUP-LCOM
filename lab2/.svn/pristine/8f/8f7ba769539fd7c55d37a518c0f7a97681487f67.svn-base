#include <minix/syslib.h>
#include <minix/drivers.h>
#include "i8254.h"
#include "timer.h"

int hookID = 0;
int counter = 0;

int timer_set_frequency(unsigned char timer, unsigned long freq) {

	unsigned char stat;

	if( timer_get_conf(timer, &stat) ){
		printf("error reading timer configurations");
		return 1;
	}

	if(freq==1){
		printf("freq cannot be 1\n");
		return 1;
	}


	unsigned short div;
	unsigned short LSB;
	unsigned short MSB;
	if(freq==0){

	}else{
	div=TIMER_FREQ/freq;
	}


	LSB = div & 0xFF;
	MSB = (div>>8) & 0xFF;




	unsigned long timer_sel;

	switch(timer){
	case 0 :
		timer_sel= TIMER_SEL0;
		break;
	case 1 :
		timer_sel = TIMER_SEL1;
		break;
	case 2 :
		timer_sel = TIMER_SEL2;
		break;
	default:
		printf("timer errado");
		return 1;
	}


	if(sys_outb(TIMER_CTRL, (stat & 0xF)|(timer_sel|TIMER_LSB_MSB))){
		printf("error in writing to control reg");
		return 1;
	}

	unsigned long porta;

	switch(timer){
		case 0 :
			porta = TIMER_0;
			break;
		case 1 :
			porta = TIMER_1;
			break;
		case 2 :
			porta = TIMER_2;
			break;
		default:
			printf("timer errado");
			return 1;
		}

	if(sys_outb(porta, LSB)){
		printf("error writing to LSB");
		return 1;
	}

	if(sys_outb(porta, MSB)){
		printf("error writing to MSB");
		return 1;
	}


	return 0;
}

int timer_subscribe_int(void ) {

	if(sys_irqsetpolicy(TIMER0_IRQ, IRQ_REENABLE,&hookID) != OK || sys_irqenable(&hookID) != OK ) {

			return -1;
	}
	return BIT(hookID);

}

int timer_unsubscribe_int() {

	if(sys_irqrmpolicy(&hookID) == OK && sys_irqdisable(&hookID) == OK)	{

		return 0;
	}
	return 1;
}

void timer_int_handler() {

	counter++;
}

int timer_get_conf(unsigned char timer, unsigned char *st) {
	
	/*retorna erro se timer introduzido nao for 0, 1 ou 2*/
	if(timer!=0 && timer!=1 && timer!=2){
		printf("erro timer_get_vonf(). timer invalido\n");
		return 1;
	}

	unsigned long read_back_cmd;
	read_back_cmd = (TIMER_RB_CMD | TIMER_RB_COUNT_ | TIMER_RB_SEL((unsigned long)timer));


	/*escrever read back command para o control register*/
	if(sys_outb(TIMER_CTRL, read_back_cmd)){
		printf("erro a escrever(sys_outb) read back cmd!\n");
		return 1;
	}

	//trocar para switch case
	unsigned long timer_port;
	if(timer==0) timer_port=TIMER_0;
	if(timer==1) timer_port=TIMER_1;
	if(timer==2) timer_port=TIMER_2;

	unsigned long status;
	/*ler a resposta ao read back command*/
	if(sys_inb(timer_port, &status)){
		printf("erro a ler resposta ao reab back (sys_inb)");
		return 1;
	}

	*st = (unsigned char)status;

	return 0;
}

int timer_display_conf(unsigned char conf) {
	
	printf("\nTimer Status: %x\n",conf);
	printf("Now for humans:\n\n");

	if(conf & BIT(7)){
		printf("Current OUT line: 1");
	} else {
		printf("Current OUT line: 0");
	}

	printf("\n");

	if(conf & BIT(6)){
		printf("Null Count bit ON!"); //ir ver a datasheet o que significa
	} else {
		printf("Null Count bit OFF!"); //ir ver a datasheet o que significa
	}

	printf("\n");

	/*if else tem de estar encadeados com TIMER_LSB_MSB em primeiro*/
	if(conf & TIMER_LSB_MSB){
		printf("Type of Access: LSB followed by MSB");
	} else if(conf & TIMER_MSB){
		printf("Type of Access: MSB");
	} else if(conf & TIMER_LSB){
		printf("Type of Access: LSB");
	} else {
		printf("Type of Access: Counter Latch Mode");
	}

	printf("\n");

	/*If elses tem de estar por esta ordem porque no mode 3 e 2 o bit 3 pode ser qualquer um e no resto ter em conta primeiro o MSB*/
	if(conf & TIMER_SQR_WAVE){
		printf("Counting Mode: 3 - Square Wave Generator");
	} else if(conf & TIMER_RATE_GEN){
		printf("Counting Mode: 2 - Rate Generator (divide-by-N counter)");
	} else if(conf & TIMER_MODE_FIVE){
		printf("Counting Mode: 5");
	} else if(conf & TIMER_MODE_FOUR){
		printf("Counting Mode: 4");
	} else if(conf & TIMER_MODE_ONE){
		printf("Counting Mode: 1 - Hardware retriggerable one-shot");
	} else {
		printf("Counting Mode: 0- Interrupt on terminal count â€“ for counting events");
	}

	printf("\n");

	if(conf & TIMER_BCD){
		printf("Counting in BCD");
	} else{
		printf("Counting in Binary");
	}

	printf("\n");

	return 0;
}

int timer_test_time_base(unsigned long freq) {

	timer_set_frequency(0,freq);


	return 0;
}

int timer_test_int(unsigned long time) {
	
	return 1;
}

int timer_test_config(unsigned char timer) {
	
	unsigned char status;

	if(timer_get_conf(timer, &status)){
		return 1;
	}

	if(timer_display_conf(status)){
		printf("status format may be wrong?- check fucntions");
		return 1;
	}

	return 0;
}
