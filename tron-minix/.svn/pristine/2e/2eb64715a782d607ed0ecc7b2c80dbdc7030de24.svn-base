#include <minix/syslib.h>
#include <minix/drivers.h>
#include <minix/driver.h>
#include <minix/com.h>
#include <minix/sysutil.h>
#include "mouse.h"
#include "i8042.h"
#include "keyboard.h"
#include "video_gr.h"

static int mouse_hook = 2;
unsigned char packet[3]="";
int sync_flag = 0;
int packet_index = 0;
unsigned long byte;

Mouse* mouse = NULL;

Mouse* newMouse() {
	Mouse* mouse = (Mouse*) malloc(sizeof(Mouse));

	mouse->x = 0;
	mouse->y = 0;

	mouse->packet_idx = 0;
	mouse->complete_packet = 0;

	mouse->leftButtonDown = 0;
	mouse->leftButtonReleased = 0;

	mouse->draw =1;

}


Mouse* getMouse() {
	if (!mouse) {
		enable_data_report();
		mouse = newMouse();
	}

	return mouse;
}

void updateMouse() {

	unsigned long b1, b2, b3;

	packet_handler();

	if (mouse->complete_packet) {
		b1 = mouse->packet[0];
		b2 = mouse->packet[1];
		b3 = mouse->packet[2];

		if ((b1 & XSIGN) != 0) {
			b2 = (0xFF & ~(0xFF & b2)); //change to FF macro
			b2 += 1;
			b2 = -b2;
		}

		if ((b1 & YSIGN) != 0) {
			b3 = (0xFF & ~(0xFF & b3));
			b3 += 1;
			b3 = -b3;
		}

		mouse->x += b2;
		mouse->y -= b3;

		if (mouse->x >= getHorResolution())
			mouse->x = getHorResolution() - 10;
		else if (mouse->x < 0)
			mouse->x = 0;

		if (mouse->y >= getVerResolution())
			mouse->y = getVerResolution() - 10;
		else if (mouse->y < 0)
			mouse->y = 0;

		if (mouse->packet[0] & BIT(0)) { //change  to macro

			mouse->leftButtonDown = 1;
			mouse->leftButtonReleased = 0;

		} else if (mouse->leftButtonDown) {

			mouse->leftButtonDown = 0;
			mouse->leftButtonReleased = 1;

		} else {
			mouse->leftButtonDown = 0;
			mouse->leftButtonReleased = 0;
		}

	}

}


void drawMouse(unsigned char * cursor, int width, int height) {

	vg_png(cursor, width, height, mouse->x, mouse->y);
	vg_copy();
}

void deleteMouse() {
	free(getMouse());
}



void packet_handler() {

	unsigned long byte;

	sys_inb(OUT_BUF, &byte);

	switch (mouse->packet_idx) {
	case 0:
		if (byte & BIT(3)) {
			mouse->packet[mouse->packet_idx] = byte;
			mouse->packet_idx = 1;
			mouse->complete_packet = 0;
		}
		break;

	case 1:
		mouse->packet[mouse->packet_idx] = byte;
		mouse->packet_idx = 2;
		mouse->complete_packet = 0;
		break;

	case 2:
		mouse->packet[mouse->packet_idx] = byte;
		mouse->packet_idx = 0;
		mouse->complete_packet = 1;
		break;

	};

}

int send_kbc_cmd(unsigned long cmd) {
	unsigned long stat;
	int i = 0;
	while (i < 8) {
		if(sys_inb(STAT_REG, &stat)!= OK) return 1;

		if ((stat & IBF) == 0) {
			if(sys_outb(KBC_CMD_REG, cmd)!= OK) return 1;
			return 0 ;
		}
		tickdelay(micros_to_ticks(20000)); //macro
		i++;
	}

	return 1;

}

int send_kbd_cmd(unsigned long cmd) {
	unsigned long stat;
	int i = 0;

	while (i < 8) {
		if(sys_inb(STAT_REG, &stat)!= OK) return 1;

		if ((stat & IBF) == 0) {
			if(sys_outb(OUT_BUF, cmd)!=OK) return 1;
			return 0;
		}
		tickdelay(micros_to_ticks(20000));
		i++;
	}

	return 1;

}

int send_mouse_cmd(unsigned long cmd) {

	if(send_kbc_cmd(0xD4)!=0) return 1;  //macro
	if(send_kbd_cmd(cmd)!=0) return 1;

	return 0;

}

unsigned long read_out_buff() {
	int i = 0;
	unsigned long data;
	unsigned long stat;

	while (i < 8) {
		if (sys_inb(STAT_REG, &stat) != OK)
			return -1;

		if (stat & OBF) {
			sys_inb(OUT_BUF, &data);

			if ((stat & (PAR_ERR | TO_ERR)) == 0)
				return data;
			else
				return -1;
		}
		tickdelay(micros_to_ticks(20000));
		i++;
	}
	return -1;

}


int disable_data_report() {
	unsigned long ret;

	while (ret != ACK) {

		if(send_mouse_cmd(0xF5) !=0) return 1; //macro
		ret = read_out_buff();

	}

	return 0;

}

int enable_data_report() {

	unsigned long ret = 0;

	disable_data_report();

	while (ret != ACK) {

		if(send_mouse_cmd(0xF4)!=0) return 1; //macro
		ret = read_out_buff();

	}

	return 0;

}

int mouse_subscribe_int(void){

	//Save original hook ID for the irq_set
	int originalHook=mouse_hook;

	//Subscribe mouse interrupts
	if(sys_irqsetpolicy(MOUSE_IRQ, IRQ_REENABLE|IRQ_EXCLUSIVE, &mouse_hook) != OK || sys_irqenable(&mouse_hook) != OK)
		return -1;

	return originalHook;
}

int mouse_unsubscribe_int(){

	//Unsubscribe mouse interrupts
	if(sys_irqdisable(&mouse_hook) != OK || sys_irqrmpolicy(&mouse_hook) != OK)
		return 1;

	return 0;
}

int mouse_enable_data_report(){

	//Write Byte to Mouse Comand to the cmd register of the kbc
	if(kbc_write(KBC_CMD_REG, BYTE_TO_MOUSE)){
		printf("Error in mouse_enable_data_report()-BYTE TO MOUSE\n");
		return 1;
	}

	//Write to the mouse the cmd we want through IN_BUF
	if(kbc_write(IN_BUF, ENABLE_DATA_REPORT)){
		printf("Error in mouse_enable_data_report()-ENABLE DATA REPORT\n");
		return 1;
	}

	//Return the mouse response (ACK,NACK,ERROR)
	return kbc_read();
}

int mouse_disable_data_report(){

	//Write Byte to Mouse Comand to the cmd register of the kbc
	if(kbc_write(KBC_CMD_REG, BYTE_TO_MOUSE)){
		printf("Error in mouse_disable_data_report()-BYTE TO MOUSE\n");
		return 1;
	}

	//Write to the mouse the cmd we want through IN_BUF
	if(kbc_write(IN_BUF, DISABLE_DATA_REPORT)){
		printf("Error in mouse_disable_data_report()-ENABLE DATA REPORT\n");
		return 1;
	}

	//Return the mouse response (ACK,NACK,ERROR)
	return kbc_read();
}

int mouse_set_stream_mode(){

	//Write Byte to Mouse Comand to the cmd register of the kbc
	if(kbc_write(KBC_CMD_REG, BYTE_TO_MOUSE)){
		printf("Error in mouse_set_stream_mode()-BYTE TO MOUSE\n");
		return 1;
	}

	//Write to the mouse the cmd we want through IN_BUF
	if(kbc_write(IN_BUF, SET_STREAM_MODE)){
		printf("Error in mouse_set_stream_mode()-ENABLE DATA REPORT\n");
		return 1;
	}

	//Return the mouse response (ACK,NACK,ERROR)
	return kbc_read();
}

int mouse_set_remote_mode(){

	//Write Byte to Mouse Comand to the cmd register of the kbc
	if(kbc_write(KBC_CMD_REG, BYTE_TO_MOUSE)){
		printf("Error in mouse_set_remote_mode()-BYTE TO MOUSE\n");
		return 1;
	}

	//Write to the mouse the cmd we want through IN_BUF
	if(kbc_write(IN_BUF, SET_REMOTE_MODE)){
		printf("Error in mouse_set_remote_mode()-ENABLE DATA REPORT\n");
		return 1;
	}

	//Return the mouse response (ACK,NACK,ERROR)
	return kbc_read();
}

int mouse_get_packet(){

	byte = kbc_read();

	packet[packet_index] = byte;

	if((packet[0] & BIT(3))==BIT(3)){
		sync_flag = 1;
	} else {
		sync_flag = 0;
		packet_index = 0;
	}
	if(sync_flag){
		packet_index++;
		if(packet_index>2){
			packet_index = 0;
			return 1;
		}
	}
	return 0;
}
